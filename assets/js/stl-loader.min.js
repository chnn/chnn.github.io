/**
 * @author aleeper / http://adamleeper.com/
 * @author mrdoob / http://mrdoob.com/
 * @author gero3 / https://github.com/gero3
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.
 *
 * Supports both binary and ASCII encoded files, with automatic detection of type.
 *
 * The loader returns a non-indexed buffer geometry.
 *
 * Limitations:
 *  Binary decoding supports "Magics" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).
 *  There is perhaps some question as to how valid it is to always assume little-endian-ness.
 *  ASCII decoding assumes file is UTF-8.
 *
 * Usage:
 *  var loader = new THREE.STLLoader();
 *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {
 *    scene.add( new THREE.Mesh( geometry ) );
 *  });
 *
 * For binary STLs geometry might contain colors for vertices. To use it:
 *  // use the same code to load STL as above
 *  if (geometry.hasColors) {
 *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: THREE.VertexColors });
 *  } else { .... }
 *  var mesh = new THREE.Mesh( geometry, material );
 */
THREE.STLLoader=function(e){this.manager=void 0!==e?e:THREE.DefaultLoadingManager},THREE.STLLoader.prototype={constructor:THREE.STLLoader,load:function(e,t,r,n){var a=this,o=new THREE.FileLoader(a.manager)
o.setResponseType("arraybuffer"),o.load(e,function(e){t(a.parse(e))},r,n)},parse:function(e){var t=this.ensureBinary(e)
return function(){var e,r,n
if(n=new DataView(t),e=50,r=n.getUint32(80,!0),84+r*e===n.byteLength)return!0
for(var a=[115,111,108,105,100],o=0;o<5;o++)if(a[o]!=n.getUint8(o,!1))return!0
return!1}()?this.parseBinary(t):this.parseASCII(this.ensureString(e))},parseBinary:function(e){for(var t,r,n,a,o,i,u,f,s=new DataView(e),l=s.getUint32(80,!0),g=!1,E=0;E<70;E++)1129270351==s.getUint32(E,!1)&&82==s.getUint8(E+4)&&61==s.getUint8(E+5)&&(g=!0,a=[],o=s.getUint8(E+6)/255,i=s.getUint8(E+7)/255,u=s.getUint8(E+8)/255,f=s.getUint8(E+9)/255)
for(var p=new THREE.BufferGeometry,d=[],w=[],c=0;c<l;c++){var y=84+50*c,h=s.getFloat32(y,!0),A=s.getFloat32(y+4,!0),T=s.getFloat32(y+8,!0)
if(g){var v=s.getUint16(y+48,!0)
0==(32768&v)?(t=(31&v)/31,r=(v>>5&31)/31,n=(v>>10&31)/31):(t=o,r=i,n=u)}for(var F=1;F<=3;F++){var b=y+12*F
d.push(s.getFloat32(b,!0)),d.push(s.getFloat32(b+4,!0)),d.push(s.getFloat32(b+8,!0)),w.push(h,A,T),g&&a.push(t,r,n)}}return p.addAttribute("position",new THREE.BufferAttribute(new Float32Array(d),3)),p.addAttribute("normal",new THREE.BufferAttribute(new Float32Array(w),3)),g&&(p.addAttribute("color",new THREE.BufferAttribute(new Float32Array(a),3)),p.hasColors=!0,p.alpha=f),p},parseASCII:function(e){var t,r,n,a,o,i
t=new THREE.BufferGeometry,r=/facet([\s\S]*?)endfacet/g
for(var u=[],f=[],s=new THREE.Vector3;null!==(o=r.exec(e));){for(i=o[0],n=/normal[\s]+([\-+]?[0-9]+\.?[0-9]*([eE][\-+]?[0-9]+)?)+[\s]+([\-+]?[0-9]*\.?[0-9]+([eE][\-+]?[0-9]+)?)+[\s]+([\-+]?[0-9]*\.?[0-9]+([eE][\-+]?[0-9]+)?)+/g;null!==(o=n.exec(i));)s.x=parseFloat(o[1]),s.y=parseFloat(o[3]),s.z=parseFloat(o[5])
for(a=/vertex[\s]+([\-+]?[0-9]+\.?[0-9]*([eE][\-+]?[0-9]+)?)+[\s]+([\-+]?[0-9]*\.?[0-9]+([eE][\-+]?[0-9]+)?)+[\s]+([\-+]?[0-9]*\.?[0-9]+([eE][\-+]?[0-9]+)?)+/g;null!==(o=a.exec(i));)u.push(parseFloat(o[1]),parseFloat(o[3]),parseFloat(o[5])),f.push(s.x,s.y,s.z)}return t.addAttribute("position",new THREE.BufferAttribute(new Float32Array(u),3)),t.addAttribute("normal",new THREE.BufferAttribute(new Float32Array(f),3)),t},ensureString:function(e){if("string"!=typeof e){var t=new Uint8Array(e)
if(void 0!==window.TextDecoder)return(new TextDecoder).decode(t)
for(var r="",n=0,a=e.byteLength;n<a;n++)r+=String.fromCharCode(t[n])
return r}return e},ensureBinary:function(e){if("string"==typeof e){for(var t=new Uint8Array(e.length),r=0;r<e.length;r++)t[r]=255&e.charCodeAt(r)
return t.buffer||t}return e}}
